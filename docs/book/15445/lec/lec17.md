# Lec18 时间戳顺序并发控制

> https://www.bilibili.com/video/BV1Cp4y1C7dv?p=18
> https://www.bilibili.com/video/BV1ti4y197EG/?spm_id_from=333.788

2PL 是并发控制的一种实现，这是一种悲观的实现，在问题出现之前阻止问题的发生。存在的问题是控制的太严导致并发度降低。

而基于时间戳顺序的并发控制则是乐观的。大致流程是根据事务的时间戳来决定事务的执行顺序。

给每一个事物赋予一个时间戳，可以用系统时钟，逻辑计数器，混合（系统时钟加逻辑计数器）三种实现方式。

本文将介绍三种并发控制方法：基础的时间戳协议，乐观的基于时间戳顺序并发控制方法(OCC)，隔离级别。

基础的时间戳顺序并发控制方法：

在这种方法中，事物读写对象不加锁。

数据库中的每一个对象（一般来说就是一行数据，也就是 Tuple）都分别记录读写时间戳，例如读时间戳记录了上一个读该记录的事物序号，而写时间戳记录了上一个写该事务的序号。每一行数据后都记录有这两个信息。

每次事务执行操作的时候都要比较读写时间戳，宗旨是不能操纵未来的数据。

* 读的情况：

事务的读时间戳应当大于事务的写时间戳才可以读，否则回滚。以读取一个事务为例：一个时间戳为 5 的事务读取一条数据时发现该数据被时间戳为 6 的事务写过了，显然不合理，回滚。反之如果时间戳为 5 的事务读取数据的时候发现该数据是被时间戳为 3 的事务写过了，那么时间戳为 5 的事务可以读取该数据。当读取完毕后，接下来要更新这条数据的读时间戳，维持到最新。然后将数据本地备份，因为该数据后续可能要被别的事务更改。


* 写的情况：

如果当前事务的时间戳小于该数据的读时间戳或写时间戳，那么立刻回滚。因为不能操纵未来的数据。否则正常操纵该数据，也就是事务的时间戳均大于该数据的读写时间戳，然后保存到本地实现可重复读。

![20220324195319](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324195319.png)

一个优化的点：在上述例子中，因为 T2 写入 A 后 T1 再次写入 A 但 T1 的时间戳低于 T2 进而导致 T1 回滚，但此时 T1 写入与否对整个业务其实没有影响，不需要回滚。

这个优化叫做托马斯写规则，也就是当前事务的时间戳小于数据的读时间戳就回滚，但是小于该数据的写时间戳时事务可以继续执行，因为后续都会被写覆盖掉。

这种算法没有死锁，因为事务没有等待。但是可能造成饥饿，以为读写都可能被未来堵死。

T2 读取的数据是建立在 T1 写好的基础上。一旦数据崩溃 T1 撤销，此时 T2 就读取的数据就不是有效数据了。

如果确定事务冲突比较少并且存活时间比较短，那么可以确定这种无锁的方法很好。

解析下来还有一种很好的优化方法：OCC 。

OCC:

读的所有数据都保存在本地，但是修改的数据都不写入磁盘，等到事务真正提交的时候再比较。

1. 读：读取过的数据都复制走，为了可重复读。
2. 校验：和别的事物比较看有没有问题。
3. 写：写入。

一个 OCC 的例子：

![20220324211713](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324211713.png)

读取过的数据都复制走，为了可重复读。

校验的时候分配一个时间戳，保证序列化。校验分为向后校验和向前校验。

向后校验：

![20220324211958](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324211958.png)

向前校验，校验和未来事物交叠部分是否冲突：

![20220324212034](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324212034.png)

如果两个事务真的串行，那么不需要校验。

![20220324212227](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324212227.png)

Ti 在 Tj 写阶段之前提交。Ti 写和 Tj 读之间是空集。

> 没看懂

校验复杂，写入的时候需要锁表。

最终目的都是为了可串行化。

## 幻读

幻读：第二次读到了一个第一次读时不存在的东西，也就是中间数据发生了更新。

![20220324214222](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324214222.png)

2PL 不能阻止幻读，因为只能锁住现存的事务，无法控制新插入的事务。

幻读有三种解决方案：

1. 重新扫描：数据执行完后重新扫描一遍相关数据看有没有出现幻读。扫描了两遍性能低。
2. 谓词锁：Where 加锁，其中 Select 加共享锁，而 Update，Insert，Delete 加互斥锁。索引加锁禁止插入。

![20220324214927](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324214927.png)

间隙锁。

串行化是最高的隔离级别，但是性能受影响。

降低隔离的程度，提高性能，但是存在一系列的问题：

脏读：读为提交，读取的数据是另一个事务还未写入的数据。

不可重复读：两次读取的数据不一样。

幻读：两次读取数据后，数据变多了导致数据不一致。

1. 串行化，可重复读，没有幻读，没有脏读。
2. 可重复读，但是允许幻读。
3. 读已提交，有可能幻读，有可能不可重复读，
4. 所有的问题都有可能发生。

![20220324220733](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324220733.png)

隔离级别的分类：

![20220324220846](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324220846.png)

实现方式:

![20220324220949](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220324220949.png)

大多数任务最高的隔离级别是没有必要的。

