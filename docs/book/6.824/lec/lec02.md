# lec02 rpc and threads

## 1. 为什么要用 Go ？为什么从 C++ 换到 Go ？

GO 提供了一些分布式领域需要的机制。例如对线程的良好支持，线程之间的锁和同步，有一个方便的RPC包。

此前使用的是 C++，但是 C++ 存在很明显的限制。例如没有一个方便易用的 RPC 包。此外 Go 是类型安全以及内存安全的。

使用 Go 很难写出因为某个bug引起某段内存上的问题，从而导致写出的程序会做出一些迷之操作的代码。这就消除了很大一类bug。并且它是一门垃圾回收型语言，不用担心对同一段内存二次释放或内存泄漏等问题，在 Go 垃圾回收器会处理这个问题。这种将多线程和垃圾回收的结合确实特别重要。

在 C++ 这种非垃圾回收型语言中使用线程其中一件很糟糕的事情。在 C++ 中你需要做一大堆的记录，这样才能弄清楚最后一个使用共享对象的线程是否已经结束使用该对象了。因为只有这样你才能释放那个对象，你最终会写一大堆代码，为了弄清楚最后一个线程是否停止使用一个对象时，程序员不得不写了一大堆代码来做引用计数或者其他一些事情。垃圾回收器可以解决这些问题。

最后，那就是 Go 很简单而 C++ 很复杂。在使用 C++ 时经常遇见的一个问题就是你写的代码出现了报错，即使只是个类型错误，你从编译器那里得到的错误信息也会非常复杂。

那么我推荐你们去看下一本名为Effective Go的书（对应的还有Effective Java，Effective C++之类）

## 2. 多线程

在分布式系统中经常会遇到一个程序需要和许多其他计算机进行通信。例如，客户端可能需要与许多服务器进行通信，或者一台服务器在同一时间可能要处理来自许多不同客户端的请求。

假设程序要做7件不同的事情，因为它要和7个不同的客户端进行通信。并且，在不编写过于复杂的代码的情况下，通过一种简单的方式来让它做这七件事情。线程实现了这个功能。在Go的文档中，这些东西被称为 Goroutine ，这也就是线程。

假设你有一个程序，以及一个地址空间

如下图，用一个正方形来表示这是一个地址空间，在这个地址空间中的是一个串行程序，并不是一个多线程程序。在该地址空间只有一条用来执行代码的线程。1 个程序计数器，一组寄存器，以及一个栈，这些是用来描述程序执行的当前状态。在一个多线程程序中，例如Go程序，你可以有多个线程，图中有好几条波浪线，每条波浪线就代表了一条线程，如果多条线程同时执行。

![20220403013042](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403013042.png)

如果在同一时间内有多条线程在执行，那每条波浪线就代表了其中的一条执行路径。但每条执行路径都有它自己的程序计数器，一组寄存器以及一个栈，每个线程在程序不同的部分执行。注意每一个独立的线程中有一个独立的栈。这些栈实际是在程序的一个地址空间中。

虽然每个线程都有独立的栈，但是都在同一个地址空间中。不同线程可以互相引用对方的栈，但是一般不这样干。

在Go中，当第一次启动程序时会运行main函数。main 函数本身就是一个goroutine，它可以做所有 goroutine 能做的事情。

## 3. I/O 并发

Go 允许程序中的不同部分做它们自己的事情。

假设，有一条正在等待从磁盘中读取数据的线程。此时可能会有一条线程，用来等待从磁盘中读取数据。当它在等待的时候，可能还有第二条线程，以用来计算或者读取硬盘中的其他东西，亦或者用来向网络发送一条信息并等待回复。因此，并发I/O也是你通过多线程所能做的其中一件事情。并发I/O只是通过多线程所能做事情的其中一件而已。

常说的并发 I/O 通常是指，假设有一个已经启动的程序，在同一时间内，它可以通过RPC来对网络上的不同服务器进行请求并且同时等待许多回复。通过多线程来做到这点，为每个RPC调用都创建一条线程，每个线程都会通过RPC调用来发送request消息，并且此时线程会进入等待。接着，当回复返回时，线程会继续执行。使用多线程可以允许我们同时进行多个网络请求。它们可以同时等待，或者也无须同时都去做一件事情。当它们觉得合适的时候，它们也可以执行其他的事情。如果可以，它们也能用来执行其他的事情。在同一时间会存在多个活动的并发I/O，允许一个活动处于等待状态，其他活动依然可以运行。

多线程可以实现多核并行。例如在大量CPU周期的繁重计算任务场景下，单线程不能重复利用多核。而通过启动了多个Goroutine并且让执行某些计算密集型任务。那么你每秒能使用的CPU周期就是原来的两倍。

因为来自于客户端所带来的负载通常都会非常的高，所以服务器能够使用多线程，并且充分利用CPU中大量核心所产生的性能很重要。

此外需要周期性的检查一些任务，例如主服务器会想去周期性地检查它的worker是否存活。假设其中一个worker故障了，需要将其中的任务交给另一台机器来做。所以需要一段时间间隔内进行检查，也就是向 worker 发送消息判断是否存活。通过启动一个Goroutine，并在其中放入一个循环操作，该循环大概的操作是：让线程沉睡1秒，然后起来执行周期任务，接着继续沉睡，如此反复进行。这种开销还很小，开销取决于线程的数量，如果创建 100万条，那么负担就很大了。

## 4. 通过异步编程，使用一条线程来保存许多其他活动的状态？

假设没有线程，如何写程序来实现一台服务器同时和多个客户端进行通信或者一个客户端可以和多个服务器进行通信？

可以通过异步编程来解决，也就是事件驱动编程。

在事件驱动编程中通常有一条线程和一个循环。这个循环所做的事情就是等待可能会触发处理的任何输入或者任何事件发生。事件可能是收到了来自某个客户端的请求，或者定时器所定的时间到了。如果你电脑上的系统是windows，windows系统上的很多程序都是以这种事件驱动的风格进行编写的，这些程序会等待你触发键盘输入，或者鼠标移动之类的事件并做出反应。

在这种事件驱动型程序中，通过一个循环中的线程来等待接收输入当它得到一个输入。例如数据包它会去弄清楚这个数据包是哪个客户端发送的。其中有一张表格，用来管理该客户端的活动，或者该客户端处于什么样的状态。例如正在读取xx文件中，然后，这个程序要求去读取下一个数据块并返回

异步编程进行并发I/O时无法使用CPU的并行能力。例如在写一个处理工作量很大的服务器程序时，需要32个核心全力运转。但是让单个循环去利用多个cpu核心，这显然非常不正常。

异步编程所带来的开销通常要比线程的开销来得更小。

你们都知道，线程是非常廉价的东西，但每条线程都在一个栈内，栈的大小可能是1kb左右。如果你有20条线程，谁会去在意这样的开销呢，如果你有100万条线程，那就得占用大量的内存了，你就得有调度表之类的东西，以此来决定该执行哪条线程。假设，在这种调度列表中你有1000条线程，那么你去使用线程的时候，代价就会变得相当高了。假设现在有这样一个场景，你有一台服务器，该服务器有一百万个客户端。你必须记录每个客户端的一些状态，这种代价就会非常高了。如果使用事件驱动编程，那么就可以很容易的写出一个高效并且开销很低的服务。

## 5. 线程和进程之间的区别是什么？

一个程序就是一个进程。这个进程有一个地址空间或者说占用了一段内存。在进程中可能有多条线程。

当运行Go程序时就会创建一个UNIX进程并开辟一块内存空间。然后，当Go进程创建Goroutine时，这些Goroutine就会出现在这个进程中。

操作系统并不关心进程内部发生了什么，也不会去关心你使用的语言是什么，这些都不是操作系统所操心的东西。但在进程中可以运行大量的线程。

在机器上运行多个进程。例如，一个编辑器或者编译器。此时操作系统会保持完全独立，编辑器和编译器都有各自的内存。但它们用的并不是同一块内存，并且也不允许它们去看其他内存的内容。这些进程之间没有太多的交互。各个进程都在各自的世界里。在任何一个程序中，线程可以共享内存，并且通过channel和 mutex之类的来进行同步。但在进程之间，不存在任何交互，这其实就是这些软件的传统结构。

## 6. 当上下文切换时，是所有的线程都在切换吗？

假设有一台单核计算机，运行的时候，一次只能做一件事情。如果此时机器上运行着多个程序，那么操作系统会让CPU的时间切片在这两个程序间来回切换。当时间片到期，操作系统就会当前运行进程的CPU时间片交给另一个进程。这是在程序层面进行的，这非常复杂。让我们重新再看下这个图

我们所使用的线程是基于操作系统所提供的线程

当操作系统进行上下文切换时,会在所知道的线程中进行切换。当cpu时钟到期，操作系统就会基于某些调度算法来选择一个不同的线程去执行。可能是这个进程中的不同线程，也可能是另一个进程中的某个线程。

此外，Go 在这方面很智能，在单个操作系统线程上巧妙地复用尽可能多的Goroutine，以此来减少开销。

操作系统可能要经历两个调度阶段来选择要执行的线程，然后，在对应进程中，Go就可以去选择运行其中某个Goroutine。

好的，所以，线程是很方便的，因为很多时候它可以允许你为每一个线程编写对应的代码

## 7. 编写线程代码时如何处理共享数据？

线程共享相同的地址空间。内存共享就是，如果有一个线程在内存中创建一个对象，其它线程也可以使用该对象。

线程中共享内存很容易出错。例如线程有一个全局变量 N ，并且该变量在不同线程间共享。一个线程只想给N递增(n=n+1)，这是不对的，因为此时其他线程可能也在同时读取或修改该数据。因为有可能两个线程都将 x 加载到寄存器上加一后再放回内存中，此时两个线程都对 n 进行了递增，但结算结构都是 1 。也就是两个线程交叉执行可能会出现 1 ，但是如果分开执行结果则是 2 。

![20220403150931](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403150931.png)

单个指令不一定是原子的，存储一个32bits的值(store)很可能是原子的。

综上，在多线程场景下针对共享状态竞争被称为 race 。也就是一个 CPU 已经执行，但另一个 CPU 要执行需要等待之前 CPU 处理结束后才能进行。可以通过加锁来解决这个问题，给数据加锁，只有在持有共享数据的锁时才能执行。在 go 中调用mutex锁来解决这个问题，也就是在共享数据前加上一个 mu.lock()，用完后再加上 mu.unlock() 。锁实现了代码块的原子性。

使用锁来解决 race 的问题有两种策略。一个是弄清楚锁机制，一次只让一条线程来访问该数据。或者修改代码不共享数据。

## 8. 协作 coordination

线程之间需要交互，例如线程 a 等待线程 b 生成数据。实际的场景是 b 爬取网页，线程 a 等待线程 b 产生的数据，此时两个线程之间需要交互，也就是协作。在 go 有很多技术可以实现这个，例如 channel。

此外线程还有一个问题是死锁，死锁有时就是线程使用过程中常见问题。

![20220403155727](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403155727.png)

线程1获得锁A并且线程2获得锁B，然后线程1需要获取锁B，也就是有时候出现持有两个锁。而且恰好发生了线程2需要保持阻塞，这就是一个死锁。通常就什么干不了。

## 9. 一个网络爬虫的例子

网络爬虫的工作是传给它一个页面的URL，然后它就会开始进行爬取内容，网页之间还有指向其他页面的链接。所以网页爬虫会试着将整个首页页面所有的链接到其它页面的地址都提取出来。

首先爬虫会将该页面中所有指向其他页面的链接提取出来。如果没有对已经爬取过的网页进行记录的话可能产生死循环。例如子页面中有指向父页面的链接。所以要记录已经爬取过的页面，下次遇到直接跳过。其实就是一个树形结构。

如果一次只获取一个页面是很慢的，可以通过增加线程实现并行爬取页面。增加并发，直到占满带宽。所以，我们想要在并发中启动多个爬虫。如何以并行的方式启动多个爬虫？此外如何得知爬虫何时完成工作？

下面是一个串行的爬虫代码，也就是深搜。

![20220403172654](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403172654.png)

如何编写代码识别已经爬取过的页面？

其中维护了一个fetched的 map ，map 的 key 是 url ，如果该 url 已经存在那么直接返回。

如果它没拿到URL，会在 map 中标记一下，表示实际上已经在抓取这个URL的页面了。接下来通过fetcher函数来提取该页面上的URL。接着，遍历这个页面上的所有URL，并且在每个页面上调用这个爬虫。通过递归调用的方式，它可以获得一个不包含重复url的map 即 fetched 。注意 map 是传址，而非传值。其中内容是共享的。在底层，Go真正要做的事情是将这个map对象的指针传给调用的每个爬虫。

## 10. 如何将代码改为并行？

首先打印当前程序的运行结果：

![20220403171532](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403171532.png)

然后在这段爬虫代码中的某处插入 Goroutine ，以此来获取并行抓取的能力。

![20220403171812](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403171812.png)

结果如下：

![20220403171602](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403171602.png)

显然结果不符合预期，例如在 Goroutine 执行之前并不会在第26行处进行等待，会离开那个循环。此时 main 函数已经退出了，也就导致了能能看到一个网页。但是循环中所创建的线程依然正在运行，也就导致了打乱了下面的输出，导致了输出结果交错。所以在此处添加 go 不起什么作用。

接下来是两个真正的并行爬虫的例子。一种是通过共享数据、对象以及锁来实现的，另一种是通过 channel 来传入信息，以此来协调不同的线程。

## 11. 通过共享数据实现并行

下面是通过使用共享数据来构建web爬虫的例子。

![20220403173013](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403173013.png)

其中所有的爬虫线程都共享了 url 表，并且所有的爬虫线程都是通过 Goroutine 来执行 ConcurrentMutex 函数，而非函数调用。

在第42行到45行处代码中添加了mutex来进行上锁，以此来防止互相争抢的情况发生，如果这里不上锁，那就会发生互相争抢的情况。假设此处两个线程都碰巧拿到了同一个 URL 如果加锁一个线程得到 false 另一个得到了 true 。如果没有加锁，两个线程都拿到了 false 。接着，这两条线程就都会去抓取这个网页。也就是希望第43行和44行的操作是原子性操作。在第43行和44行处，不希望其他线程也来读取并修改这个 map 。所希望的情况是，在没有其他线程干扰的情况下，每条线程都能读取到当前map中的内容，并对其内容进行更新。这也就是互斥锁实现的功能。

第51行，爬虫会按照平时的方式去抓取该页面。第56行的循环处遍历所有fetch函数所得到的URL。第58行，每对一个URL进行抓取时就会启动一个Goroutine。第58行处的func语法，它是一个闭包函数或者说即时函数。func这个关键字所做的就是用来声明函数。然后我们就可以调用这个函数。你可以将一个函数当做一段数据那样通过func来声明，然后往里面放入参数，接着再给出函数体。这就是一个函数声明。例如输入1或者23之类的东西时就是在声明一个常数对象。这是定义常数函数的一种方式，此处这样做是想启动一个Goroutine来运行此处声明的函数。为了使用Goroutine，需要在想用 Goroutine 的地方加上一个go关键字。接着必须调用这个函数。

其实可以直接 go concurrentMutex，但此处想要做更多的操作所以定义成了一个常数函数。当 ConcurrentMutex 完成时，即在外层函数返回前，等待爬虫完成它的工作。第 55 行的 waitGroup，它是一个由Go所定义的数据结构，它能用来帮助go进行协程间任务的协调执行。在waitGroup内部有一个计数器counter。第57行 done.Add(1) 来增加计数器的数字。当 waitGroup 调用 done 的时候，计数器就会减一。第63行调用的 wait 方式是用来等待计数器归零。waitGroup 中的 wait 方法是用来等待一定数量的事情完成。这里是用来等待最后一个Goroutine结束。因为每创建一个Goroutine 就会往waitGroup中加一。在第60行这个函数的末尾处声明了一个done.Done()，这样waitGroup中的计数器就会减一。然后在第63行会一直等待，直到计数器为0为止。声明这个函数的理由在于既能调用concurrentMutex，又能调用Done。

如果其中一个子Goroutine故障了，无法到达这里的Done的话。例如除零，引用空指针可能会导致故障，函数执行失败。解决这个问题的正确方法是不去管这个Goroutine是否正常运行，在Done前面放defer关键字来延迟执行。也就是说，不管它能否完成，最终都会调用defer里的方法。

## 12. 当两个不同线程都调用了Done，为什么这样做不会引起线程间的争抢？

答案是在waitGroup内部有了mutex或者其他类似的东西存在
在做任何事情前，每个done方法都会先获取这个东西。所以连续调用一个waitgroup中的done方法是不会引起线程争抢的情况发生

我们可以从底层入手，在C++和C中，我们会去看某种称为pthread的东西。在C语言中，线程是由一个库来提供的，它并不是语言中的一部分，它被称为pthread，它们是所有语言中最为传统和古老的原语。虽然这并没有在代码中出现，你可以把waitgroup看作是计数器那样来使用，waitGroup并不在意你要计数的是什么东西。这其实是它最常见的用法

## 13. 为什么在第58行将u作为参数传入这个函数？

第58行所定义的函数规则是，如果函数体内提到的变量在外层函数中已经声明过，但并没有隐藏的话，那么内部函数会使用和外层函数相同的变量。例如，此处第60行fetcher，它和外层函数中的fetcher是同一个变量。如果直接使用在第56行的循环处所定义不可行，因为循环的缘故， u 的值在不断的被更新。这意味着启动了第一个Goroutine后，并查看外部函数中的u变量，当外部函数更新u变量的值时，第一个Goroutine会看到变量u中更新后的值。对于 f 来说这正是所期待的，但是对于 u 来说不行。类似传值和传址的区别。通过传参的方式实现了一个私有拷贝。

## 14. 如果内部函数引用了包裹它的这个外围函数中的一个变量但这个外围函数return了？

因为外部函数已经return了，那么内部函数所引用的会怎样呢。答案是go会去分析你的内部函数（这些函数也被称为闭包函数），编译器会去分析它们。编译器表示这个闭包函数使用了外部函数中的一个变量。实际上，编译器会分配一段heap内存来保存这个变量的当前值，这两个函数都会引用这个heap内存中所保存的这个变量。正如你们所期待的那样，这个变量并不会存放在stack内，如果编译器看到它在一个闭包函数中使用，那么这个变量就会移动到heap内存中。当外部函数return，这个对象仍然会保存在heap中，内部函数依然能够获取到它。然后垃圾收集器负责观察最后一个引用这段heap内存的函数什么时候return。只有到了那个时候，垃圾收集器才会将它释放。

## 15. 不使用锁会发生什么？

线程间竞争。
我们来看下如果不加锁的话，代码在运行时会发生什么呢？

![20220403182952](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403182952.png)

看输出似乎没有问题，但是这段代码仍然是错的。问题在于只试了两次，如果试几百次问题可能就发生了。

所以一些代码看起来很合理，但是因为使用了共享变量导致了一些未知的结果出现。在实际中需要能够找出线程 race 的工具。Go 提供了这个工具，在Go程序时加上-race这个参数，就可以进行检测了。检测当前代码并来看下结果。

![20220403183752](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403183752.png)

使用 race 后程序会去跟踪一些线程获取和释放锁以及执行其他强制线程无法进行并行操作的同步活动的行为。

## 16. 在这个爬虫程序中，它创建了多少个线程？

线程不能无限使用，数千个线程可能没什么问题，但是一个真实的网站可能有数十亿条线程。而每个线程都占用了一定的内存，创建太多线程容易把内存耗尽。可以通过创建固定大小的线程池来实现，其中线程数量固定，通过复用线程来抓取 url 。而非每发现一个 url 就创建一个线程。

通过 channel 可以实现。但是在 channel 的实现中并不会用到这个map，也不会去共享内存，更不需要去用到锁。其中有一个主线程，在第86行处有一个map，但这个map是这个master函数所私有的。

![20220403185703](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403185703.png)

master 函数所做的并不是像之前那个爬虫程序那样通过一系列类似树状的函数调用来对网络路径图进行抓取。之前那个爬虫例子每抓取一个URL就会启动一个Goroutine。但在这个例子中，只有一个master会去创建这些线程。此处并不会通过树状函数来创建这些线程，而是只通过这个master来做

master 在第 88 行创建了它自己的 map，其中记录了它所抓取的URL。然后它也创建了一个channel，所有的worker 线程都会和这个单个 channel 进行通信，其背后的思路就是启动一个worker线程。启动的每个worker 线程在工作（例如，提取页面）结束后都会将一个确切的item通过channel发送回 master 。并且 item 也就是worker 线程所获取的 page 中 URL 的列表。所以在这个master中有一个循环。在第89行，我们从channel中读取数据

SO，想象一下有这么一个场景，我们需要提前启动一些worker线程，现在，它读取到了这些worker所返回的URL列表信息，每次他都会在第89行去爬一个URL，然后从第90行的单个页面获取该URL列表中的URL。如果这个URL并没有被抓取，它就会在第94行启动一个新的worker去抓取这个URL。如果我们看下从第77行起的worker代码。这里面它调用了fetcher，接着在第80或82行处将信息发送给channel。并表示这是它们在页面上所抓取的URL。注意一下，此处有一件事可能令我们比较感兴趣，那就是worker线程并不共享任何对象，在worker和master之间不存在任何共享对象，所以无须去关心锁相关的问题，也无须关心线程争抢的问题。这就是一个通过channel来交流信息的例子，它并不是不是通过共享内存来实现。当master在读取channel时，worker会去修改channel

但是Go作者并不想让你们去这样思考。他们想让你这样思考，ch是一个channel，channel具有发送和接收这两个操作。worker线程会往channel中发送信息，然后master则是从channel中获取信息，这完全合情合理。channel对此也会很高兴，我真正想说的是在channel的内部实现中，它里面有一个mutex。channel 操作通过在内部维护一个锁来保证多个线程使用它时不会发生任何races，channel就是用来保护变量以应对并发场景。在并发的情况下，Go 允许你们在不同线程间使用 channel。我们不需要关闭channel，我的意思是，当爬虫已经完全完成了它的工作时，即我们抓取了每一条URL，我们就会使用break语句，我想说的是这个n是个私有值，master每启动一个worker线程，n就会加1。每个worker都会往channel中发送一个item。每当master从channel中读取到一个item时，master就知道其中一个worker完成了它自身的任务，当n变为0时，那我们的工作就结束了。

![20220403191247](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220403191247.png)

一旦worker的数量变为0，那么这个channel就只有master在引用，垃圾收集器就会发现这点，即没有其他东西去引用这个channel了，它就会将这个channel释放掉。某些情况下，你们需要去关闭channel，但实际上我很少去关闭channel，你们可以看到在第106行，在调用master之前。ConcurrentChannel会先发送一个url到channel中，这是为了让所有的工作开始进行。因为这段代码是为了master而写的，你们知道，在第89行处master才会去读取channel中的信息，So，最好有些东西在channel里面不然在第89行，我们就会一直堵塞下去。

如果在第107行没有这段代码的话，那么第89行的for循环就会在读取channel信息时一直卡住，这段代码也就没法工作了。
如果能写些代码来让master注意到目前在channel上没有任何东西，这不会很nice吗，确实可以这么做，如果你看下select语句，它要远比这个复杂得多。但在select语句中，如果channel上没有什么等待的东西的话，它就允许你在不阻塞的情况下继续处理。因为worker并没有结束工作，抱歉，打断一下，你问的第一个问题是，我们实际是否能够并行启动。在最开始，我们并不会并行，Well，我们并没有接收到结果，for循环会在第89行处等待
好吧，我来解释下。第89行处的for循环所做的并不仅仅是对当前channel中的内容进行处理，然后离开，第89行的for循环要做的是进行读取，并且它可能永远不会结束，它会等，直到channel中有东西出现时，对channel进行读取。如果你无法触发第99行的break，那么这个for循环就不会结束，我想时间差不多了，我们该下课了。
之后我会让助教们安排一场关于Go的讲座，到那时我会和你们再多聊点跟Go相关的内容。