# Lec01: 课程介绍和关系模式

## 1. 这门课讲什么？

这门课主要解决如下问题：什么是数据库？如何存储数据？如何进行查询？如何执行事务管理？遇到冲突或重启该怎样恢复？

此外将会扩展一些高级主题，例如分布式数据库，一些其他类型的数据库或关系型数据库的扩展。以及如何在云环境下扩展。

第一个作业是根据提供的 SQL Lite 数据库写一些数据库查询。

项目则是构建一个功能完整的数据库管理系统。项目是基于 C++17 编写的。

## 2. 为什么需要 DBMS ？

最初是用 CSV 文件来存数据，其中数据以逗号分隔开来。例如Artist和Album会分别存为单独的csv⽂件。

![20220405144921](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405144921.png)

在Artist中，Artist有三个属性，即名称，年份以及国家。在 Album 这个实体中保存了专辑名称，艺术家信息以及发布年份。如果⽤CSV⽂件存储它们，需要在每个属性上⽤引号标明，然后⽤逗号将它们分开。

然后编写程序从中提取想要的值。例如查询 Artist ，遍历每一行找出Ice Cube在哪⼀年单⻜。

![20220405145054](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405145054.png)

只需检查数组中第⼀个属性是不是Ice Cube。如果是的话，那我们就将第二个属性转换为整数，因为这是想打印的年份。通过简单的代码就找到了这个查询所要找的内容。

以上的查询方法存在一些问题，正是因为这些问题推动了 DBMS 的产生。

1. 写死了查询的位置，第一个必须是人名，第二个必须是年份，第三个必须是国家，不能改变顺序，一旦改变顺序查询代码需要随着变动。此外 Ice Cube 拼写错误怎么办？

2. 如何保证数据符合规则，也就是数据一致性。例如年份本来应该是四位的整数，但是如果是字符串怎么办？

3. 一张专辑由多个艺术家制作的话该怎么存数据，此时艺术家的名字需要改成数组来存，但此时是一个字符串。

4. 此前是通过遍历来查找文件中的内容，但是如果有数十亿条数据遍历显然很慢。如何快速处理？
5. 查询的代码是用 python 写的，如果想用另一种语言来对数据库进行查询该怎么办？例如通过手机应用程序来查询数据库。
6. 如果两个线程对同一个文件同时进行写入会发送什么？如果不做任何处理，第二个线程将会覆盖第一个线程所写的内容进而导致文件数据丢失。
7. 如何保证数据是安全的？例如打开文件更新了一条数据，但是在结束更新之前机器出故障了。当后续再次打开时究竟是更新完了还是更新了一半？正确的状态该是什么？

以上的一些问题就是为什么不想通过解析文件的方式来查询的原因。DBMS 解决了这些问题，程序无需关心底层的实现情况，并且多个应用可以复用，不必重复造轮子。

这门课将会设计一个通用的 DBMS，允许应用程序对数据库进行定义，创建，查询，更新及管理。数据库是存在硬盘中的，而非是内存或 GPU 或其他类型的数据库。

## 3. DBMS 的演化

将关系转化为简单的数据结构然后存⼊数据库。关系就是表的结构。

最初人们不相信软件能够生成像人工那样高效的查询计划。就像不相信任何编译器都无法生成和手写汇编一样高效的机器码一样。当然现在都已经改观了。所有⼈都使用高级语言去编写代码，编译器能很好地生成比手写汇编更高效的机器码。但当时来说并不是这样。

数据库管理系统决定了数据库的物理存储。数据之间的存储关系取决于数据库系统的实现，也就是通过关系模型不能决定究竟是存在内存中或存在磁盘中，也不能决定如何组织数据。对于应用程序来说这些都是透明的。这样做的好处是当下层代码变动时上层应用程序代码就不需要改变。这样就将逻辑层和物理层分开了。

关系模型并非唯一，但却是最广泛的数据模型。

NoSQL系统通常是 Key/Value，Graph，Document，JSON或者Column-family这些数据模型。

对于机器学习来说，最常用的数据模型是数组或矩阵。

## 4. 关系型数据模型的三部分

关系是一组无序元素或者记录。这些元素或记录的属性⽤来表示关系中实体的实例。

用 tuple 来表示关系模型中的一组数据。例如 Artist 表中有三个字段，即 name，year 以及 country 其中一行数据就是一个 tuple 。

每个属性都是原子的，也就是不能是数组或嵌套对象等，可以是字符串，整数，浮点数等。目前可以存 JSON 对象，也可以存 NULL 这个特殊值。但是查询的时候可能会引起一些问题，这取决于如何实现。

relation 和 table 这两个术语实际上是⼀回事。通常讲 tuple 称为记录，而非行，虽然这俩概念差不多一个意思，但是也有区别行是很具体的东西，后续会讲。

主键，能够唯一标识一条记录的属性或属性组。之前的例子中没有主键，因为姓名可能重名，可以通过引入一个新的字段 id 作为唯一主键。

外键，用来和另一张表关联，能够确认另一张表的记录字段。当插入数据时不会将数据映射到另一张表上未知或不存在的实体上。例如如何在一张专辑表中存储多个艺术家。此时因为 artists 字段需要保证原子性，所以不能存放多个值。

![20220405161527](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405161527.png)

此时可以设置一张独立的交叉引用表来解决这个问题。将 Artist 中的 id 字段作为外键使⽤，然后和这些艺术家所参与的专辑 id 产⽣关联。

![20220405161644](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405161644.png)

此时就可以将多位艺术家存储在一个专辑中，数据库管理系统将追踪这些albums和artists的id之间是否存在真正的关联关系。

![20220405161851](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405161851.png)

所以这可以防⽌在 album 表中插⼊⼀位不存在的艺术家。此时不需要写额外的代码数据库系统就可以防⽌插⼊错误数据了。

## 5. 如何在数据库中取出想要的数据？

此前提供了一个通过 for 循环来提取数据的例子。但这样做的效率很低。

![20220405162651](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405162651.png)

DML 是⼀种操作数据的⽅式，通过 DML 可以访问或修改数据库中的数据。

此处有**通过程序**和**非程序性（声明式）**两种访问方式。前者则是自己指明了具体的执行流程，当然这个和之前的 Python 代码也不同。后者则是希望 DBMS 生成执行流程，最后返回结果即可，具体执行流程交给系统管理。

## 6. 关系代数

关系代数是过程语⾔(procedural language)的⼀个例⼦。Ted Codd 提出了在关系代数中七种基本运算符：

![20220405163310](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405163310.png)

这些运算符用来操作某个表中的记录生成并返回想要的结果，这也是用来处理表的基本操作。

此外这些代数是基于集合的，而集合是无序的列表或无序的集合，其中元素可以重复。SQL 使用关系代数作为执行查询的基础运算符。

每个关系操作符会使用一个或多个关系作为输入然后输出一个新的关系，也就是将复杂的查询通过关系操作符链接在一起，然后生成想要的答案。只⽤select、projection、Union、intersection、difference、product以及join这些操作符就能完成。接下来会逐个讨论。

## 7. select

select操作可以根据⼀些查询条件来得到符合条件的tuples的⼀个⼦集，因此可以将其看作一个过滤器。例如给定一些输入关系，对每个 tuple 进行条件判断，结果为 true 就将其添加进我们的输出关系中。有个记住这个select的简单⽅法，那就是select是S开头，并且它的关系操作符σ也是S开头。

在下面这个例⼦的关系中，我们有两个属性，即a_id和b_id。可以做⼀个像上⾯写的查询操作，找到我所有a_ID是a2的tuple 。查出的（数据）将与这2张表做关联，同结构或同属性作为输⼊关系。然后输出即是这两张表在某个新关系下的产物，并且该关系具有与输⼊关系相同的结构或相同的属性。

![20220405164715](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405164715.png)

此时并没有指定条件的判断顺序，如何交换条件的判断顺序可能代价会更高！这都留给了数据库系统来决定。

## 8. projection

生成一个新的输出关系，里面包含了输入关系中指定属性的子集。

![20220405165141](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405165141.png)

projection的开头字⺟为p，并且它使⽤⼩写的π作为符号，因此很容易记住它是哪个。

例如关系R跟A_ID，B_ID，执行一个简单的查询。通过 select 操作,得到 R 关系（即 a_id='2' ）下的查询结果，然后就是 projection 操作。将 b_id的值减去100，即根据 a_id 的值查询得到的结果再去做这个操作。因此，可以以想要的⽅式来对属性进⾏重排序，然后可以使用⼀种算术或某种字符串函数运算符来得到⼀种想要的⽅式来进⾏操作。

## 9. union 

Union 操作符的作⽤是将两个关系组合⽣成⼀个新的关系，这其中包含了这两个关系中的全部 tuple 。

![20220405165743](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405165743.png)

此处只需将这两个关系合并即可。如果对R和S进⾏Union操作将会得到⼀个⼤的集合，其本质就是将S对R进⾏级联然后得到⼀个输出。对于这个操作符⽽⾔，当想对两个关系进⾏Union操作时，这两个关系必须具有相同属性以及相同类型才⾏。在这个例⼦中，如果S有第三个属性就不能进⾏Union操作，因为没办法匹配。在SQL中有⼀个UNION ALL操作符，但这个UNION ALL和关系代数中的Union操作符并不是完全⼀样的。你必须添加这些限定符才能按照你想的那样进⾏。下节课去讨论它们俩之间的区别

## 10. Intersection

对于 Intersection 操作符也是⼀样，将两个关系作为输⼊，然后就会⽣成⼀个包含了在两个关系中都出现过的tuple的输出关系。

![20220405165953](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405165953.png)

只有⼀个tuple在R和S中都出现了，那就是a3和103。只有当R与S都具有相同属性，相同类型以及相同名字时，关系代数中的Union才能正常⼯作。对于SQL中这个INTERSECT关键字，同样如此。

## 11. Difference

Difference 操作的作⽤是只取在第一个关系中出现的元素，⽽不是第二个关系中的元素（相当于从第⼀个元素集中将第二个元素集中出现的东⻄都过滤掉）

![20220405170240](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405170240.png)

也就是说，对于R-S，可以拿到所有出现在R但并没有出现在S的tuple。在这个例⼦中，a3和103在R和S中都出现了，因此，它并不在输出⾥⾯，但a1和a2并没有出现在S中，因此它们在输出结果⾥⾯。在SQL中，可以使⽤EXCEPT关键字来做到相同的事情。

## 12. Product

有时它也被叫做笛卡尔积，在SQL被称为交叉连接（Cross Join）。通过它来从两个输⼊关系中生成所有tuple的可能组合。当使⽤笛卡尔积时，这就会产⽣⼀个巨⼤的输出，这⾥⾯包含了所有可能的不重复的组合。

![20220405170404](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405170404.png)

在SQL中可以使⽤CROSS JOIN，实际上如果不明确使⽤哪种JOIN，就会得到这样的输出。

## 13. Join

此处的 Join 被称为⾃然连接（Natural Join），对于⼀个关系中的每个 tuple 是否与另⼀个关系中具有相同名称，相同类型的所有属性匹配，

![20220405170654](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405170654.png)

在这个例⼦中，如果想对R和S进行自然连接。在 a_id 中查看是否匹配，看 R 中 a_id 和 S 中 a_id 对上了。a3 103在R和S中都存在，因此作为输出结果。

和Difference不同的原因是因为在R和S中，它们可能会有⼀些额外属性，但是这些属性的名字在这两个关系中并不相同。实际上它们不会出现在输出结果中。在使⽤Join时，我们允许这些公共属性的名字可以不同，但在DIfference操作符中，我们必须有完全相同的属性以及类型。

## 14. 其他运算符

之前的七个运算符是Ted Codd所提出的最核⼼的关系操作符。此后许多⼈为此做了⼤量研究以及增加了额外的东⻄。

![20220405172804](https://cdn.jsdelivr.net/gh/weijiew/pic/images/20220405172804.png)

例如排序，虽然原版的关系模型没有讨论，但是后续有人将其整合进其中，使得关系代数变得更强大。

可以通过排序来消除那些名字重复的东⻄。后续会用到聚合和排序。

当执行查询时，必须要考虑关系代数运算符。和此前的 for 循环相比，关系代数更为高级。因为此处关系代数并没有明确如何存储数据，选用怎样的数据结构，只是声明想要的结果是什么。

此外选择不同的运算符可能会得到相同的结果，但是效率却是完全不同的。例如R和S中有⼗亿条数据，但在S中，只有⼀个tuple中的b_id是102。如果先进行 join 也就是说对S中的⼗亿条tuple和R中的⼗亿条tuple进⾏Join。然后对结果进行扫描找到个b_id为102的tuple。
但是如果先扫描找到那个b_id为102的tuple，⽤这一条tuple和R中的⼗亿条tuple进⾏ Join 。二者的效率差别很大。