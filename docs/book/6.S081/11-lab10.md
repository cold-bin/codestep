# Lab mmap

切换分支：

    $ git fetch
    $ git checkout mmap
    $ make clean


实现 mmap 和 munmap 功能，通过 mmaptest 测试程序。

1. 首先增加系统调用。

2. 接下来实现 sys_mmap，sys_munmap 。

       void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);


1. 第一个参数是一个你想映射到的特定地址，如果传入null表示不指定特定地址，这样的话内核会选择一个地址来完成映射，并从系统调用返回。
2. 第二个参数是想要映射的地址段长度len。
3. 第三个参数是Protection bit，例如读写R|W。
4. 第四个参数暂时跳过不做讨论，它的值可以是 MAP_PRIVATE 。它指定了如果你更新了传入的对象，会发生什么。（注，第四个参数是flags，MAP_PRIVATE是其中一个值，在mmap文件的场景下，MAP_PRIVATE表明更新文件不会写入磁盘，只会更新在内存中的拷贝，详见man page）。
5. 第五个参数是传入的对象，在上面的例子中就是文件描述符。
6. 第六个参数是offset。

通过上面的系统调用，可以将文件描述符指向的文件内容，从起始位置加上offset的地方开始，映射到特定的内存地址（如果指定了的话），并且连续映射len长度。这使得你可以实现 Memory Mapped File，你可以将文件的内容带到内存地址空间，进而只需要方便的通过普通的指针操作，而不用调用read/write系统调用，就可以从磁盘读写文件内容。这是一个方便的接口，可以用来操纵存储在文件中的数据结构。实际上，你们将会在下个lab实现基于文件的 mmap，下个lab结合了XV6的文件系统和虚拟内存，进而实现 mmap。

mmap还可以用作他途。除了可以映射文件之外，还可以用来映射匿名的内存（Anonymous Memory）。这是sbrk（注，详见8.2）的替代方案，你可以向内核申请物理内存，然后映射到特定的虚拟内存地址。


       int munmap(void *addr, size_t length);