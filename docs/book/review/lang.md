# c++

## 1. C++11 新特性有什么？

C++11 是 C++ 语言的一个重要版本，提供了许多新特性和改进，包括：

- 模板 alias：可以为模板定义别名，以简化代码。

```cpp
template<typename T>
using MyVector = std::vector<T, std::allocator<T>>;

MyVector<int> v;
```

上面的代码定义了一个名为 MyVector 的别名，它是一个 `std::vector<T, std::allocator<T>>` 的简写。因此，我们可以直接使用 MyVector 来定义一个元素类型为 int 的 vector 对象。

- 初始化列表：可以使用 {} 进行初始化，避免代码冗长。

```cpp
std::vector<int> v{1, 2, 3, 4};
```

- 类型推导：可以自动推导变量的类型，减少代码冗长。

```cpp
auto x = 42;
```

- 区间 for：可以简化循环语句，并使得代码更加易读。

```cpp
std::vector<int> v{1, 2, 3, 4};
for (int x : v)
  std::cout << x << " ";
```

- Lambda 表达式：支持在代码中匿名定义函数，简化代码。

```cpp
std::vector<int> v{1, 2, 3, 4};
std::for_each(v.begin(), v.end(), [](int x) { std::cout << x << " "; });
```

- 并发支持：提供了多线程编程的功能，包括互斥量、条件变量、原子操作等。

原子操作：
```cpp
#include <atomic>
```

```cpp
std::atomic<int> x(0);
++x;
```

共享锁：
```cpp
#include <shared_mutex>
```

```cpp
std::shared_mutex m;
std::unique_lock<std::shared_mutex> l(m);
```
线程库：
```cpp
#include <thread>
#include <vector>

std::vector<std::thread> threads;
for (int i = 0; i < 5; ++i)
  threads.emplace_back([i]() { std::cout << i << " "; });
for (auto& t : threads)
  t.join();
```

异步任务：
```cpp
#include <future>

auto f = std::async([]() { return 42; });
std::cout << f.get() << std::endl;
```

- 静态断言：可以在编译时进行断言，提高代码的可靠性。

```cpp
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```

- 智能指针：提供了更加方便的内存管理机制，避免内存泄漏问题。

```cpp
std::unique_ptr<int> p1(new int(42));
std::shared_ptr<int> p2 = std::make_shared<int>(42);
```

- 右值引用，移动语义。

右值引用是 C++11 中的一项新特性，它用于表示临时对象的引用。它的特点是可以对一个将要销毁的对象进行引用，从而在许多情况下大大提高了程序效率。

右值引用是以两个及以上个 & 符号表示的：

```cpp
int&& r = 42;
```

上面的代码声明了一个名为 r 的右值引用，它引用了一个临时对象 42。右值引用的一个重要用途是实现移动语义，即可以使用右值引用将一个对象从一个地方移动到另一个地方，而不是复制。例如：

```cpp
std::string s1 = "hello";
std::string s2 = std::move(s1);
```

在上面的代码中，我们使用了 `std::move` 函数将 s1 的所有权转移到了 s2。这种做法可以避免构造临时对象和销毁对象，从而大大提高程序效率。

- uniform initialization、构造函数别名等。

uniform initialization 是 C++11 中的一项新特性，它允许使用一种统一的语法初始化所有类型的对象，包括类、数组、标准库容器等。

```cpp
int x{42};
std::vector<int> v{1, 2, 3};
```
在上面的代码中，我们使用了大括号 {} 进行初始化，这是一种统一的初始化语法。

- 构造函数别名

构造函数别名是 C++11 中的一项新特性，它允许在一个类的作用域内定义构造函数的别名，以更加方便地调用。

```cpp
class Foo
{
public:
    Foo(int x, int y) : x_(x), y_(y) {}

    Foo(int x) : Foo(x, 0) {}
};
```

在上面的代码中，我们使用了 Foo(int x) 构造函数的别名，它直接调用了 Foo(int x, int y) 构造函数。

## 2. 什么是左值，什么是右值，什么时候用到右值，`move` 是干啥的（超高频了）

右值引用和移动语义一起使用，可以大大提高程序效率。移动语义是通过右值引用移动对象而不是复制它，从而节省复制对象的代价。

例如：

```cpp
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

void swap(int &&a, int &&b)
{
    int temp = std::move(a);
    a = std::move(b);
    b = temp;
}
```

在上面的代码中，我们定义了两个 swap 函数，一个用于处理左值，一个用于处理右值。在处理右值的 swap 函数中，我们使用了右值引用和移动语义，使用 std::move 函数移动右值而不是复制它。

这样做的好处是，当我们处理临时对象时，可以避免复制对象，提高程序效率。而对于左值，则仍然使用传统的交换方式，维护其不变性。

为什么右值可以避免复制代价，提高效率？

当我们复制一个对象时，会发生以下操作：

- 首先，构造一个临时的对象。
- 然后，复制临时对象到目标位置。
- 最后，析构临时对象。

这些操作都是需要代价的，特别是当对象大时，复制代价会非常昂贵。

但是，对于右值，它是一个临时的、不可修改的对象，生命周期很短。因此，我们可以将其**移动**到目标位置，从而避免复制代价，提高效率。

注意**移动**和**复制**不等价，二者的区别在于复制会创建一个新的对象并将原对象的值复制到新对象中，而移动并不创建一个新对象，而是将原对象的资源直接移动到目标对象中。这样就不需要进行复制操作，从而提高效率。右值本质上是**移动**，而左值是**复制**。

使用右值引用来代替复制，从而避免复制代价，提高效率，是移动语义的核心思想。我们可以定义移动构造函数和移动赋值运算符，从而让编译器在合适的情况下使用移动语义来代替复制，从而避免复制代价，提高效率。

因此，右值在提高效率的关键在于：右值是一个临时对象，生命周期很短，因此我们可以直接将其移动到目标位置，从而避免复制代价。

## 3. 移动构造函数/移动赋值运算符函数的流程是什么？

移动构造函数/移动赋值运算符函数的流程如下：

- 首先，移动构造函数/移动赋值运算符函数会接收一个右值引用作为参数，这个右值引用代表的是将要被移动的对象。
- 接着，移动构造函数/移动赋值运算符函数将原对象的资源直接移动到目标对象中。
- 然后，移动构造函数/移动赋值运算符函数将原对象的资源指针设为 null，以防止在原对象生命周期结束后资源被释放两次。
- 最后，移动构造函数/移动赋值运算符函数返回目标对象。

整个移动构造函数/移动赋值运算符函数的流程都是一种尽量快速，尽量有效地移动原对象的资源到目标对象中的操作，从而提高效率。

## 4. C++ 的 `new` 运算符流程

C++ 的 new 运算符流程如下：

- 首先，C++ 中的 new 运算符申请内存空间。它调用底层的内存分配函数，如 malloc，给目标对象分配内存。
- 然后，new 运算符调用目标对象的构造函数，在分配的内存中初始化对象。
- 最后，new 运算符返回指向初始化好的对象的指针。

如果构造函数抛出异常，new 运算符会自动释放内存，并抛出相应的异常。如果内存分配失败，new 运算符会抛出 `std::bad_alloc` 异常。

## 5. 调用构造函数流程

## 6. `malloc` 函数返回的地址是什么地址

虚拟地址， `malloc` 返回什么样的地址，如果分配10字节。

说了下 `malloc` ，在分配空间小于128k使用 `brk` 系统调用，将堆区顶部上推

实际上不是每次都调用，会维护内存池，把一堆空闲块，用链表链接起来
    -   面试官追问，如果链表太长咋办？
    -   我就把C++ allocator的二级空间配置器的原理搬过来了（维护不同块长度的空闲链表）
    -   这个链表的并发访问，除了加锁还有啥方法吗
    -   说了下原子操作（也不知道对不对）
    -   了解thread local吗？（听过名字，没了解具体原理，寄）

-   【动态链接库】和【静态链接库】的区别？
    -   我本来想先说【动态链接】和【静态链接】的区别的，我就试图先说这个，想杀点时间
    -   但是，又问静态库 `.a` 和动态库 `.so` 有啥不同。麻了，没回答上，回去好好看
    -   然后又追问，怎么查看使用到的动态链接库？麻了，忘了，滚去复习（寄）
-   C++ 一般用啥编译工具？
    -   make、cmake
-   有什么工具，能查看编译后可执行文件的函数？
    -   objdump
    -   其他想不到了，失忆了（寄）
-   你用到了protobuf，知道protobuf是怎么存的吗？（指的是底层怎么进行的序列化）
    -   不知道，只知道序列化后是二进制的
-   用 protobuf 的好处
    -   八股文
-   看过什么开源库（关于存储的）
    -   我可不敢说leveldb，省的被怼死
    -   就说没看过
-   了解mysql吗？（面试官很无奈，其他啥也不知道，mysql总知道吧）
    -   了解
-   mysql存储引擎，用的什么数据结构？
    -   B+树
-   B+树怎么查询的？
    -   八股文
    -   失算了，本来想等着面试官问点更深的东西，看来我应该主动说点mysql（innodb/myisam）对B+树的具体实现
-   为什么用B+树，不用B树？
    -   八股文
-   知道 `unique_ptr` 吗？
    -   知道，是独占所有权的智能指针
-   怎么实现独占所有权？怎么转移所有权？
-   `b = a;` 怎么实现？`b = move(a);` 怎么实现？
    -   就是说了移动构造函数/移动赋值运算符的流程
-   知道 `shared_ptr` 吗？
    -   知道，是共享所有权的智能指针
-   怎么实现的共享所有权？
    -   引用计数
-   引用计数和管理的内存地址怎么实现的？是同一块内存空间吗？
    -   都在堆区
    -   `make_shared` 会放在同一个空间
-   引用计数和管理的内存是相生相依的吗？
    -   没搞懂，最后就问了这两个是同时创建的吗？
    -   其实不是，传入 `new xxx` 的构造函数就不是
-   同样问了 `shared_ptr` 的 `b = a;` 怎么实现？`b = move(a);` 怎么实现？
    -   同样说了下拷贝构造函数/拷贝赋值运算符、移动构造函数/移动赋值运算符的流程

-   你经常使用C++是吧，那你用过智能指针吗？
    -   没用过，但是我了解过原理
-   面试官追问，如果没用过，你是怎么管理指针的？
    -   确保new、delete成对出现
    -   在构造函数中new、析构函数中delete
    -   当然，以后写项目，会尽可能使用的，毕竟大一点的项目，谁也不能这么精确的控制new、delete成对出现
-   可以解释智能指针的原理吗？
    -   说了shared_ptr的原理，引用计数
    -   感觉没答好
-   shared_ptr循环引用问题？怎么解决？
    -   双向链表节点
    -   weak_ptr（在聊天框里面还傻逼的拼成了week_ptr，面试官还提醒我了）

## 1. const 的作用
- 在 C++ 中，"const" 是一个修饰符，用于声明一个变量或函数的值不能被修改。它可以应用于变量和函数的声明，以防止误用。

-   例 1：声明常量变量
```cpp
const int MAX_SIZE = 100;
```


这个变量 MAX_SIZE 的值不能被修改。

-   例 2：常量参数
```cpp
void print_array(const int arr[], int size) {
    //...
}
```

这个函数的参数数组arr 不能被修改.

-   例 3：常量返回值
```cpp
const std::string& get_name() {
    static std::string name = "Alice";
    return name;
}
```

这个函数返回一个string 的引用是常量, 所以不能修改返回值.

-   例 4：常量指针

```cpp
int value = 10;
const int* ptr = &value;
```

这里 `ptr` 是指向 int 类型的常量指针，它指向的值不能通过该指针修改。

总而言之，使用 const 修饰符声明变量是为了提高代码的可读性和可维护性，可以避免因为误用导致的错误。

## 2. static 作用？

在 C++ 中，"static" 是一个关键字，可以用来实现多种不同的功能。具体而言，可以在类中、函数中、局部变量中使用。

-   例 1: 静态全局变量 
```cpp
static int counter = 0;
```

这里的 counter 是静态成员变量，它不属于任何特定的类对象，而是属于整个类。

-   例 3: 静态局部变量

```cpp
void MyFunction() {
    static int counter = 0;
    //...
}
```

这里的 counter 是静态局部变量，它在函数第一次被调用时被初始化，并在后续调用中保留它的值。

-   例 4: 静态函数

```cpp
static void MyStaticFunction() {
    //...
}
```

这里的 MyStaticFunction 是静态函数，它只在定义它的文件中可见。

总而言之，使用 static 修饰符是在为类和函数提供一种访问控制，可以限制它们的作用域，并且在变量，局部变量的作用域中提供了静态存储。



## 3. this


-   `this` 在 C++ 中，`this` 是一个指针，它指向调用成员函数的对象。在类的成员函数中，可以使用 `this` 指针来访问当前对象的成员。 例如:

```cpp
class MyClass {
    int x;
public:
    void set_x(int x) {
        this->x = x;
    }
};
```



## 4. inline 

`inline` 修饰符用于修饰函数，表示这个函数将被编译器内联展开，而不是生成函数调用的代码。 这样能够提高程序的运行效率,但是会增加编译文件的大小。 例如：
```cpp
inline void MyFunction() {
    //...
}
```


-   虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
-  `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。


## 5. volatile

-   volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
-   volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
-   const 可以是 volatile （如只读的状态寄存器）
-   指针可以是 volatile


## 6. assert()

断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。


## 7. sizeof()
-   sizeof 对数组，得到整个数组所占空间大小。
-   sizeof 对指针，得到指针本身所占空间大小。


## 8. this 

- 指向调用该成员函数那个对象。
- 当对象调用成员函数时，编译程序首先将对象的地址赋给 this 指针，然后调用成员函数。每次成员函数存取数据成员时，都隐式调用 this 指针。


## 9. Struct 和 Class 的区别

- 默认的访问控制：struct 是 public ，而 class 是 private 。



## 10. C 实现 C++ 类？
- 封装：使用函数指针把属性与方法封装到结构体中。
- 继承：结构体嵌套。
- 多态：父类和子类方法的函数指针不同。



## 11. new 和 malloc 的区别？
1. 申请内存所在位置：
	1. new 从自由存储区申请内存，而 malloc 从堆中申请内存。
	2. 自由存储区是建立在堆上，在 C++ 中使用 new 和 delete 抽象出来的概念。
2. new 返回的是对象指针，而 malloc 返回的是 `void *` 



## 12. epoll










# 1. 内联函数

普通函数在调用的时候需要入栈，如果操作频繁会导致栈内存大量消耗。

内联函数每次调用都复制了代码消耗的空间，省去了函数调用的开销。

inline 放在函数声明前不会起作用。必须放在函数定义体前。

如果函数调用的开销小于（代码长/有循环）函数本身运行的开销那么不建议使用内联。

不能在递归中使用。

1. 相当于把内联函数里面的内容写在调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，却比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。


    // 声明1（加 inline，建议使用）
    inline int functionName(int first, int second,...);

    // 声明2（不加 inline）
    int functionName(int first, int second,...);

    // 定义
    inline int functionName(int first, int second,...) {/****/};

    // 类内定义，隐式内联
    class A {
        int doA() { return 0; }         // 隐式内联
    }

    // 类外定义，需要显式内联
    class A {
        int doA();
    }
    inline int A::doA() { return 0; }   // 需要显式内联


优缺点

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。



# 2. const

1. 修饰变量，变量内容不能被改变。

2. 修饰指针，分为常量指针和指针常量两种类型。

    这样记：const后边的内容为“常量”。
    const int  ptr;   //ptr为常量，初始化后不可更改
    const int* ptr;   //*ptr为常量，不能通过*ptr改变它指向的内容 
    int const* ptr;   //*ptr为常量，同上
    int* const ptr;   //ptr为常量，初始化后不能再指向其它地址

3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改。不能更改所修饰的引用，但是引用本身所存储的内容可以更改。

    void main(void)
    {
        int i = 10;
        int j = 100;
        const int &r = i;
        int const &s = j;
        r = 20;          //错，不能改变内容
        s = 50;          //错，不能改变内容
        i = 15;          // i和r 都等于15
        j = 25;          // j和s 都等于25
    }


4. 修饰成员函数，说明该成员函数内不能修改成员变量。

    class MyClass
    {
        char *str ="Hello, World";
        MyClass()
        {
            //void constructor
        } 
        ~MyClass()
        {
    //destructor 
        }
    
        char ValueAt(int pos) const    //const method is an accessor method
        {
            if(pos >= 12)
                return 0;
    *str = 'M';       //错误，不得修改该对象
            return str[pos];     //return the value at position pos
        }
    }

# 3. static

1. 修饰变量的时候，变量存储在静态区中。在 main 函数启动的时候就分配空间。
2. 修饰函数的时候只能在文件内起作用，主要是防止命名冲突。
3. 修饰成员变量的时候，所有的成员变量都只保存一个该变量并且不用生成对象就可以直接访问。
4. this 指针，

# 4. this

表示调用该成员函数的对象本身。

# 5. volatile

volatile 修饰的变量可能会被其他因素修改，所以编译器不应当优化。每次访问的时候必须从内存中取值。

# 6. assert()

断言，是宏，而非函数。如果它的条件返回错误，则终止程序执行。

# 7. sizeof()

* sizeof 对数组，得到整个数组所占空间大小。
* sizeof 对指针，得到指针本身所占空间大小。

# 8. #pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐


# 9. friend 友元类和友元函数

能访问私有成员
破坏封装性
友元关系不可传递
友元关系的单向性
友元声明的形式及数量不受限制

# 10. 宏

宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。
 
# 11. 面向对象

封装：将客观事物抽象成类。

继承：父类，子类。

多态：


# 12. 纯虚函数与虚函数的区别与作用



# 宏定义 #define 和 const 常量

* 宏定义 #define	const 常量
* 宏定义，相当于字符替换	常量声明
* 预处理器处理	编译器处理
* 无类型安全检查	有类型安全检查
* 不分配内存	要分配内存
* 存储在代码段	存储在数据段
* 可通过 #undef 取消	不可取消





# 参考

https://www.nowcoder.com/discuss/205497

https://github.com/huihut/interview

https://leetcode-cn.com/circle/discuss/QhuDiK/



# Go



## 1. golang 中 make 和 new 的区别？ #card 
- make 用来初始化内置的数据结构（slice, map, Channel），new 则是根据传入类型为其分配一片内存空间并返回指向这片内存空间的指针。
- new只分配内存，make用于slice，map，和channel的初始化。
- make 默认生成 0 。


## 2. 数组和切片的区别？ #card 
- 数组长度固定，切片长度可变。
- 数组中存值类型，切片中存引用。所以在函数中传递数组会产生副本，而传递切片不会产生副本，因为全是引用。
- 无法通过 len 获取数组长度，但可以获取切片长度。


## 3. go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？#card 
- 简介：在 Go 中，`defer` 关键字用于在函数返回前延迟执行一个语句或函数。这个语句或函数被称为“延迟函数”。延迟函数的执行是在函数返回之前以后进先出（LIFO）的顺序执行的。也就是说，最后被延迟的函数会最先被执行。
- 顺序：先正着执行函数语句，再倒着回头执行 go defer 。类似 java 的 try catch 或 C++ 中的析构函数。
- 目的：`defer` 语句通常用于在函数结束前释放资源，例如关闭文件、释放锁、关闭数据库连接等。
- 思考：我认为这样设计是为了保证 defer 语句始终在最后执行，可以方便的添加操作。
- 其他：panic 会等待之前的defer执行完成后才会触发。

## 4. 介绍 rune 类型 #card 
- 在 Go 中，`rune` 类型是一个类似于 `int32` 的类型，它用于表示一个 Unicode 码点。例如可以使用 `rune` 类型来存储字符 `'a'`：


## 5. for range 的时候它的地址会发生变化么? #card 
- 以 `for _, v := range studs` 为例，会返回下标和 studs 指针两个变量。但是指针是不变的，变化的是存储的内容。如果直接对 $v 会导致存储的内容均为同一个地址。



## 6. uint 类型字节个数？ #card 
- 和系统相关，32 位系统长度为 32 ， 64 位系统长度为 64位。 


## 7. select 选择的随机性 #card 
- 类似 switch ，但是若没有指明选择哪个分支执行会存在随机性。以下三个原则：
	-  执行能返回的。
	- 若存在多个能返回的则随机选取一个。
	- 若均无法返回则执行 return 。



## 8. Go 语言函数调用和 C 函数调用的区别？ #card 
- C 语言函数调用需要同时使用寄存器（ eax 寄存器传递返回值）和栈，而 Go 只需要栈即可。
- 因为访问寄存器的速度要快于访问栈的速度，所以 C 语言的效率更高，但实现复杂且需要考虑不同架构寄存器差异，而 Go 实现简单，不用考虑不同寄存器的差异，但是性能差。

## 9. Go 函数参数传递是传值还是传址？ #card 
- Go 传递基本数据类型，结构体和指针均采用传值的方式。


## 10. Go 中 context 的结构及其应用？ #card 
- 在不同协程之间传递信息。
```go
type Task struct {
    ID        int
    Name      string
    CancelCtx context.Context // 用于取消任务
    CancelFn  context.CancelFunc
}

func (t *Task) Run() {
	// 使用一个无限循环，每次循环中都会检查任务的取消状态
	for {
        select {
        case <-t.CancelCtx.Done():
            // 任务被取消，退出
            return
        default:
        }

        // 执行任务
        fmt.Printf("Running task %d (%s)\n", t.ID, t.Name)
        time.Sleep(time.Second)
    }
}

func main() {
    tasks := []*Task{
        {ID: 1, Name: "Task 1"},
        {ID: 2, Name: "Task 2"},
        {ID: 3, Name: "Task 3"},
    }

    // 启动所有任务
    for _, task := range tasks {
	    // 为每个任务创建一个可取消的 context
        task.CancelCtx, task.CancelFn = context.WithCancel(context.Background())
        go task.Run()
    }
	// 等待 5 秒后取消第二个任务
    time.Sleep(time.Second * 5)

    // 取消第二个任务
    tasks[1].CancelFn()
}
```


## 11. 切片和数组的异同？ #card 
- 切片是对数组的封装，可以理解为动态数组，当数组内容不够时可通过 append 来扩容。
- 数组是一片长度连续的内存空间，而切片是一个结构体，由长度，容量，底层数组三个变量组成。长度表示当前数据个数，而容量表示总容量。
- 切片是如何扩容的？
	- 因为底层数组申请完后空间不可变所以当容量不够之时会重新申请一篇内存，并将原始数据复制过去。
	- 扩容数据量的差异？
		- 1.18 之前：当原 slice 容量小于 `1024` 的时候，新 slice 容量变成原来的 `2` 倍；原 slice 容量超过 `1024`，新 slice 容量变成原来的`1.25`倍。
		- 1.18 之后：当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量 $$newcap = oldcap+(oldcap+3*256)/4$$

## 12. map 底层原理 #card 
- Go 语言采用数组加链表的方式，当节点达到一定个数（8）之后会转为红黑树。
- Go 扩容是创建一个更大的 hash 表，将数据迁移过去。

## 13、有时候会遇到一些空的结构体，这个目的是什么？
空结构体不占任何内存，使用空结构体，可以帮咱们节省内存空间，提升性能golang


## 14. append 返回值不处理有什么问题?(slice 扩容) 
在 Go 语言中，使用 `append` 函数往 slice 中添加元素时，如果 slice 的容量不足以容纳新的元素，`append` 函数会创建一个新的底层数组并返回一个新的 slice，原来的 slice 也会指向新的底层数组。

2. 如何在编译时检查是否实现接口( var _ interface = (*type)(nil); ) 

在 Go 语言中，使用 `append` 函数往 slice 中添加元素时，如果 slice 的容量不足以容纳新的元素，`append` 函数会创建一个新的底层数组并返回一个新的 slice，原来的 slice 也会指向新的底层数组。

如果在调用 `append` 函数时不处理它的返回值，就会导致原来的 slice 不再指向新的底层数组，而是指向原来的底层数组。这会导致在后续的操作中使用原来的 slice 访问数据时出现问题，因为它指向的底层数组并不包含最新的数据。

因此，在使用 `append` 函数时，应该将其返回值赋值给原来的 slice，以确保它指向的是最新的底层数组。

例如：

`s := []int{1, 2, 3} s = append(s, 4)`

这样就可以确保在后续的操作中使用的是最新的 slice，避免出现问题。

3. goroutine 如何出让执行/被挂起? (提sleep, chan, Gosched都行) 
4. goroutine 很多会有什么问题？(应提到调度延迟、内存占用、协程池)



##  15. 协程和线程的区别？
- 概念
	- 线程是 OS 的基本调度单位，轻量级的进程。
	- 协程是用户态的轻量级线程，由程序员显示控制。
- 地址空间
	- 线程之间共享同一地址空间
	- 协程之间不共享同一地址空间，只能在同一个进程中切换。因为协程是在用户态执行，需要依赖程序支持，上下文信息由程序维护，因此协程并不共享地址空间。而线程的信息是由 OS 来维护，共享同一地址空间。
- 切换开销：
	- 线程的切换开销大，协程的切换开销小。
	 - 协程有程序控制更有针对性，而线程由 OS 控制，所以协程开销小。
- 适用场景：
	- 线程需要大量并发执行的场景。
	- 协程需要细粒度控制的场景。

### 作业帮(一面)
1.  channel实现
2.  go调度原理
3.  select和epoll的区别
6.  时序数据库如何实现
10.  数据库中的乐观锁悲观锁
11.  程序中的乐观锁和悲观锁
12.  二叉搜索树,两个节点被交换了位置,怎么恢复

## context相关
-  Context 结构是 Go 的标准库中为了管理和传递上下文信息（如请求的超时时间和请求的唯一标识符）而设计的一个类型。Context 类型是一个接口，它可以通过调用 context.With* 方法来创建不同类型的子上下文。
1、context 结构是什么样的？
2、context 使用场景和用途

## channel相关

1、channel 是否线程安全？锁用在什么地方？

2、go channel 的底层实现原理 （数据结构）

3、nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型）

4、向 channel 发送数据和从 channel 读数据的流程是什么样的？

## map 相关

1、map 使用注意的点，并发安全？

2、map 循环是有序的还是无序的？

3、 map 中删除一个 key，它的内存会释放么？

4、怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？

5、 nil map 和空 map 有何不同？

6、map 的数据结构是什么？是怎么实现扩容？

## GMP相关

1、什么是 GMP？（必问）

2、进程、线程、协程有什么区别？

3、抢占式调度是如何抢占的？

4、M 和 P 的数量问题？

## 锁相关

1、除了 mutex 以外还有那些方式安全读写共享变量？

2、Go 如何实现原子操作？

3、Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？

4、Mutex 有几种模式？

5、goroutine 的自旋占用资源如何解决

## 并发相关

1、怎么控制并发数？

2、多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？

3、如何优雅的实现一个 goroutine 池（百度、手写代码）

## GC相关

1、go gc 是怎么实现的？（必问）

2、go 是 gc 算法是怎么实现的？ （得物，出现频率低）

3、GC 中 stw 时机，各个阶段是如何解决的？ （百度）

4、GC 的触发时机？  

## 内存相关

1、谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？

2、知道 golang 的内存逃逸吗？什么情况下会发生内存逃逸？

3、请简述 Go 是如何分配内存的？

Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？

4、介绍一下大对象小对象，为什么小对象多了会造成 gc 压力？


# MP


## 1. 主键生成策略，雪花算法。

可以选择 AUTO 自增，也可以选择雪花算法的生成模式。

雪花算法：分布式ID生成器

雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性。

核心思想：

长度共64bit（一个long型）。

首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，

所以id一般是正数，最高位是0。

* 41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。
* 10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。
* 12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID）。

优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高。


# 容器

## ConcurrentHashMap

