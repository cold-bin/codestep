
# 参考

https://github.com/huihut/interview

https://leetcode-cn.com/circle/discuss/QhuDiK/

# 内联函数

普通函数在调用的时候需要入栈，如果操作频繁会导致栈内存大量消耗。内联函数每次调用都复制了代码消耗的空间，省去了函数调用的开销。

inline 放在函数声明前不会起作用。必须放在函数定义体前。

如果函数调用的开销小于（代码长/有循环）函数本身运行的开销那么不建议使用内联。

不能在递归中使用。

https://blog.csdn.net/zqixiao_09/article/details/50877383

1. 相当于把内联函数里面的内容写在调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，却比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。


    // 声明1（加 inline，建议使用）
    inline int functionName(int first, int second,...);

    // 声明2（不加 inline）
    int functionName(int first, int second,...);

    // 定义
    inline int functionName(int first, int second,...) {/****/};

    // 类内定义，隐式内联
    class A {
        int doA() { return 0; }         // 隐式内联
    }

    // 类外定义，需要显式内联
    class A {
        int doA();
    }
    inline int A::doA() { return 0; }   // 需要显式内联


优缺点

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

# 虚函数 


# const

1. 修饰变量，变量内容不能被改变。
2. 修饰指针，分为常量指针和指针常量两种类型。

    这样记：const后边的内容为“常量”。
    const int  ptr;   //ptr为常量，初始化后不可更改
    const int* ptr;   //*ptr为常量，不能通过*ptr改变它指向的内容 
    int const* ptr;   //*ptr为常量，同上
    int* const ptr;   //ptr为常量，初始化后不能再指向其它地址

3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改。不能更改所修饰的引用，但是引用本身所存储的内容可以更改。

    void main(void)
    {
        int i = 10;
        int j = 100;
        const int &r = i;
        int const &s = j;
        r = 20;          //错，不能改变内容
        s = 50;          //错，不能改变内容
        i = 15;          // i和r 都等于15
        j = 25;          // j和s 都等于25
    }


4. 修饰成员函数，说明该成员函数内不能修改成员变量。

    class MyClass
    {
        char *str ="Hello, World";
        MyClass()
        {
            //void constructor
        } 
        ~MyClass()
        {
    //destructor 
        }
    
        char ValueAt(int pos) const    //const method is an accessor method
        {
            if(pos >= 12)
                return 0;
    *str = 'M';       //错误，不得修改该对象
            return str[pos];     //return the value at position pos
        }
    }


# 宏定义 #define 和 const 常量

* 宏定义 #define	const 常量
* 宏定义，相当于字符替换	常量声明
* 预处理器处理	编译器处理
* 无类型安全检查	有类型安全检查
* 不分配内存	要分配内存
* 存储在代码段	存储在数据段
* 可通过 #undef 取消	不可取消

# static

* 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
* 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
* 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
* 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

# this 指针

1. this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。
4. this 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：`const ClassName* const，这说明 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
5. this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）。
6. 在以下场景中，经常需要显式引用 this 指针：
   1. 为实现对象的链式引用；
   2. 为避免对同一对象进行赋值操作；
   3. 在实现一些数据结构时，如 list。







