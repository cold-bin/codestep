# 1. 内联函数

普通函数在调用的时候需要入栈，如果操作频繁会导致栈内存大量消耗。

内联函数每次调用都复制了代码消耗的空间，省去了函数调用的开销。

inline 放在函数声明前不会起作用。必须放在函数定义体前。

如果函数调用的开销小于（代码长/有循环）函数本身运行的开销那么不建议使用内联。

不能在递归中使用。

1. 相当于把内联函数里面的内容写在调用内联函数处；
2. 相当于不用执行进入函数的步骤，直接执行函数体；
3. 相当于宏，却比宏多了类型检查，真正具有函数特性；
4. 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
5. 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。


    // 声明1（加 inline，建议使用）
    inline int functionName(int first, int second,...);

    // 声明2（不加 inline）
    int functionName(int first, int second,...);

    // 定义
    inline int functionName(int first, int second,...) {/****/};

    // 类内定义，隐式内联
    class A {
        int doA() { return 0; }         // 隐式内联
    }

    // 类外定义，需要显式内联
    class A {
        int doA();
    }
    inline int A::doA() { return 0; }   // 需要显式内联


优缺点

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。



# 2. const

1. 修饰变量，变量内容不能被改变。

2. 修饰指针，分为常量指针和指针常量两种类型。

    这样记：const后边的内容为“常量”。
    const int  ptr;   //ptr为常量，初始化后不可更改
    const int* ptr;   //*ptr为常量，不能通过*ptr改变它指向的内容 
    int const* ptr;   //*ptr为常量，同上
    int* const ptr;   //ptr为常量，初始化后不能再指向其它地址

3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改。不能更改所修饰的引用，但是引用本身所存储的内容可以更改。

    void main(void)
    {
        int i = 10;
        int j = 100;
        const int &r = i;
        int const &s = j;
        r = 20;          //错，不能改变内容
        s = 50;          //错，不能改变内容
        i = 15;          // i和r 都等于15
        j = 25;          // j和s 都等于25
    }


4. 修饰成员函数，说明该成员函数内不能修改成员变量。

    class MyClass
    {
        char *str ="Hello, World";
        MyClass()
        {
            //void constructor
        } 
        ~MyClass()
        {
    //destructor 
        }
    
        char ValueAt(int pos) const    //const method is an accessor method
        {
            if(pos >= 12)
                return 0;
    *str = 'M';       //错误，不得修改该对象
            return str[pos];     //return the value at position pos
        }
    }

# 3. static

1. 修饰变量的时候，变量存储在静态区中。在 main 函数启动的时候就分配空间。
2. 修饰函数的时候只能在文件内起作用，主要是防止命名冲突。
3. 修饰成员变量的时候，所有的成员变量都只保存一个该变量并且不用生成对象就可以直接访问。
4. this 指针，

# 4. this

表示调用该成员函数的对象本身。

# 5. volatile

volatile 修饰的变量可能会被其他因素修改，所以编译器不应当优化。每次访问的时候必须从内存中取值。

# 6. assert()

断言，是宏，而非函数。如果它的条件返回错误，则终止程序执行。

# 7. sizeof()

* sizeof 对数组，得到整个数组所占空间大小。
* sizeof 对指针，得到指针本身所占空间大小。

# 8. #pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐


# 9. friend 友元类和友元函数

能访问私有成员
破坏封装性
友元关系不可传递
友元关系的单向性
友元声明的形式及数量不受限制

# 10. 宏

宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。
 
# 11. 面向对象

封装：将客观事物抽象成类。

继承：父类，子类。

多态：


# 12. 纯虚函数与虚函数的区别与作用



# 宏定义 #define 和 const 常量

* 宏定义 #define	const 常量
* 宏定义，相当于字符替换	常量声明
* 预处理器处理	编译器处理
* 无类型安全检查	有类型安全检查
* 不分配内存	要分配内存
* 存储在代码段	存储在数据段
* 可通过 #undef 取消	不可取消





# 参考

https://www.nowcoder.com/discuss/205497

https://github.com/huihut/interview

https://leetcode-cn.com/circle/discuss/QhuDiK/